<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <title>Image → ICO</title>
</head>
<body>
  <h1>Image → .ico converter</h1>
  <p>
    <label for="file">Choose an image (jpg, png, gif, webp, svg): </label>
    <input id="file" type="file" accept="image/png,image/jpeg,image/gif,image/webp,image/svg+xml" />
  </p>

  <p>Select size:</p>
  <label><input type="checkbox" name="size" value="16" style="display: inline; margin: 5px;">16x16</label>
  <label><input type="checkbox" name="size" value="32" style="display: inline; margin: 5px;">32x32</label>
  <label><input type="checkbox" name="size" value="48" style="display: inline; margin: 5px;">48x48</label>
  <label><input type="checkbox" name="size" value="64" style="display: inline; margin: 5px;">64x64</label>
  <label><input type="checkbox" name="size" value="128" style="display: inline; margin: 5px;">128x128</label>
  <label><input type="checkbox" name="size" value="256" checked  style="display: inline; margin: 5px;">256x256</label>

  <p>
    <button id="convert">Convert to .ico</button>
  </p>

  <div id="result"></div>

  <script>
    "use strict";

    const fileInput = document.getElementById("file");
    const convertBtn = document.getElementById("convert");
    const resultDiv = document.getElementById("result");

    convertBtn.addEventListener("click", async () => {
      clearResult();

      const file = fileInput.files && fileInput.files[0];
      if (!file) {
        appendText("Please choose an image file first.");
        return;
      }

      const sizes = [...document.querySelectorAll(".size:checked")]
        .map(cb => parseInt(cb.value, 10))
        .filter(n => Number.isFinite(n) && n > 0)
        .sort((a,b) => a - b);

      if (sizes.length === 0) {
        appendText("Select at least one icon size.");
        return;
      }

      try {
        console.log("Loading image…");
        const img = await loadImageFromFile(file);

        console.log("Rendering PNGs for each size…");
        const pngBuffers = await Promise.all(sizes.map(sz => rasterizeToPngBuffer(img, sz)));

        console.log("Assembling ICO…");
        const icoBlob = buildIcoFromPngs(pngBuffers, sizes);

        const baseName = (file.name || "icon").replace(/\.[^.]+$/,"") || "icon";
        const icoName = baseName + ".ico";

        const url = URL.createObjectURL(icoBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = icoName;
        a.textContent = "Download " + icoName + " (" + formatBytes(icoBlob.size) + ")";
        resultDiv.appendChild(a);

        console.log("Done.");
      } catch (err) {
        console.error(err);
        appendText("Conversion failed: " + (err && err.message ? err.message : String(err)));
      }
    });

    function clearResult() {
      resultDiv.innerHTML = "";
    }

    function appendText(text) {
      const p = document.createElement("p");
      p.textContent = text;
      resultDiv.appendChild(p);
    }

    function formatBytes(n) {
      if (n < 1024) return n + " B";
      const units = ["KB","MB","GB"];
      let u = -1;
      do { n /= 1024; u++; } while (n >= 1024 && u < units.length - 1);
      return n.toFixed(1) + " " + units[u];
    }

    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          URL.revokeObjectURL(url);
          resolve(img);
        };
        img.onerror = e => {
          URL.revokeObjectURL(url);
          reject(new Error("Unsupported or corrupt image."));
        };
        img.src = url;
      });
    }

    async function rasterizeToPngBuffer(img, size) {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;

      const ctx = canvas.getContext("2d");
      // Transparent background
      ctx.clearRect(0, 0, size, size);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      const iw = img.naturalWidth || img.width || 0;
      const ih = img.naturalHeight || img.height || 0;

      let scale = 1, dw = size, dh = size, dx = 0, dy = 0;

      if (iw > 0 && ih > 0) {
        scale = Math.min(size / iw, size / ih);
        dw = Math.max(1, Math.round(iw * scale));
        dh = Math.max(1, Math.round(ih * scale));
        dx = Math.floor((size - dw) / 2);
        dy = Math.floor((size - dh) / 2);
      }
      // Draw while preserving aspect ratio (letterbox)
      ctx.drawImage(img, dx, dy, dw, dh);

      const blob = await canvasToPngBlob(canvas);
      const buf = await blob.arrayBuffer();
      return new Uint8Array(buf);
    }

    function canvasToPngBlob(canvas) {
      return new Promise(resolve => {
        if (canvas.toBlob) {
          canvas.toBlob(b => resolve(b), "image/png");
        } else {
          // Fallback for very old browsers
          const dataUrl = canvas.toDataURL("image/png");
          resolve(dataUrlToBlob(dataUrl));
        }
      });
    }

    function dataUrlToBlob(dataUrl) {
      const [header, data] = dataUrl.split(",");
      const isBase64 = /;base64$/i.test(header);
      const mime = (header.match(/data:([^;]+)/i) || [,"application/octet-stream"])[1];
      const bytes = isBase64 ? atob(data) : decodeURIComponent(data);
      const arr = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
      return new Blob([arr], { type: mime });
    }

    // Build an ICO file that contains PNG-encoded images (valid on Windows, macOS, Linux, and browsers)
    function buildIcoFromPngs(pngUint8Arrays, sizes) {
      if (pngUint8Arrays.length !== sizes.length) {
        throw new Error("Size mismatch building ICO.");
      }

      const count = sizes.length;
      const headerSize = 6 + count * 16; // ICONDIR (6) + N * ICONDIRENTRY (16)
      const header = new ArrayBuffer(headerSize);
      const dv = new DataView(header);

      let p = 0;
      dv.setUint16(p, 0, true); p += 2;     // Reserved
      dv.setUint16(p, 1, true); p += 2;     // Type = 1 (icon)
      dv.setUint16(p, count, true); p += 2; // Count

      // Compute offsets
      let offset = headerSize;
      const sizesInRes = pngUint8Arrays.map(u8 => u8.byteLength);

      for (let i = 0; i < count; i++) {
        const size = sizes[i];
        const w = size >= 256 ? 0 : size; // 0 means 256 in ICO header
        const h = size >= 256 ? 0 : size;

        dv.setUint8(p++, w);            // Width
        dv.setUint8(p++, h);            // Height
        dv.setUint8(p++, 0);            // Color count (0 = no palette / >= 8bpp)
        dv.setUint8(p++, 0);            // Reserved
        dv.setUint16(p, 1, true); p+=2; // Planes (1 is fine for PNG-in-ICO)
        dv.setUint16(p, 32, true); p+=2;// Bit count (hint; PNG is used)
        dv.setUint32(p, sizesInRes[i], true); p+=4; // Bytes in resource
        dv.setUint32(p, offset, true); p+=4;        // Image offset
        offset += sizesInRes[i];
      }

      const parts = [new Uint8Array(header), ...pngUint8Arrays];
      return new Blob(parts, { type: "image/x-icon" });
    }
  </script>
</body>
</html>
